datil.html에서 append를 처리할 때 location.assign('/index.html')하면 index.html에 붙여진다.

------------------------------------------------------------------------------------------------

10/16

JAVA란 무엇인가요?
자바는 객체지향 프로그래밍 언어입니다.
JAVAとは何ですか。
Javaはオブジェクト指向のプログラミング言語です。

객체지향 프로그래밍 언어란 무엇인가요?
객체지향 프로그래밍이란 프로그램을 개발하는 기법으로 부품에 해당하는 개체들을 먼저 만들고 이것들을 하나씩 조립 및 연결하여 전체 프로그램을 완성하는 것입니다. 
자동차를 생각하면 빠른 이해가 될 수 있습니다. 자동차를 만들때 부품들을 하나씩 먼저 만들고, 부품들어 하나씩 조립하여 완성본인 자동차를 만들죠? 이와같다고 할 수 있습니다. 
때문에 유지보수와 확정성면에서 좋습니다.

オブジェクト指向のプログラミング言語とは何ですか？
オブジェクト指向プログラミングとはプログラムを開発する技法で、部品に該当する個体を先に作り、それらを1つずつ組立てて全体のプログラムを完成させることです。
自動車のことを考えると、すぐに理解できます。自動車を作る時、部品を一つずつ先に作って、部品を一つずつ組み立てて完成させた自動車を作りますね。このように言うことができます。
そのため、メンテナンスや確定性が好ましいです。

객체 지향의 장점
1. 캡슐화
필요한 속성(Attribute)과 행위(Method)를 하나로 묶고 그중 일부를 외부에서 사용하지 못하도록 은닉한다. 관련된 코드와 데이터가 묶여있고 오류가 없어 사용이 편리합니다. 
데이터를 감추고 외부 세계와의 상호작용은 메서드를 통하는 방법인데, 라이브러리로 만들어 업그레이드하면 쉽게 바꿀 수 있습니다.

2. 상속 (Inheritance)
이미 작성된 클래스를 이어받아서 새로운 클래스를 생성하는 기법으로 위에서 말한 기존 코드를 재활용해서 사용하 것을 의미합니다. 
객체지향 방법의 큰 장점 중 하나입니다. 

3. 다형성 (Polymorphism)
하나의 이름(방법)으로 많은 상황에 대처하는 기법입니다. 개념적으로 동일한 작업을 하는 함수들에 똑같은 이름을 부여할 수 있으므로 코드가 더 간단해지는 효과가 있습니다.


オブジェクト指向の長所
1.Encapsulation
必要なAttributeとMethodを一つにまとめ、その一部を外部で使用できないように秘匿する。関連するコードとデータが縛られていて、エラーがないため、使いやすいです。
データを隠し、外部との相互作用はmethodを介しての方法ですが、ライブラリにしてアップグレードすれば容易に変えられます。

2.Inheritance
すでに作成されたクラスを受け継いで新しいクラスを生成する技法で、上記の既存のコードを再利用することを意味します。
オブジェクト指向方法の大きな長所の一つです。

3.Polymorphism
1つの手法で多くの状況に対処する手法です。概念的に同じ作業をする関数に同じ名前を付与することができるため、コードがより簡単になる効果があります。

------------------------------------------------------------------------------------------------


10/17


HTTP란 무엇인가요?
http는 웹브라우저와 서버간의 웹페이지 같은 자원을 주고 받을 때 쓰는 통신 규약입니다. 이렇듯 규약이 있기 때문에, 모든 프로그램이 이 규칙에 맞춰 개발하고 서로 정보를 교환할 수 있습니다.
HTTP는 연결상태를 유지하지 않는 비연결성 프로토콜입니다. 이것을 개선하기 위해서 COOKIE와 SESSION이 등장하였습니다.

HTTPS란 무엇인가요?
HTTP프로토콜의 보안 버전입니다. 인증서를 통해 암호화 및 인증으로 보안이 더욱 강화됩니다.

HTTPS를 적용한 이유는 무엇인가요?
HTTP는 단순 텍스트교환이기 때문에 내용이 노출될 수가 있습니다. 하지만, HTTPS는 HTTP의 SSL(TLS)라는 인증서를 이용하여 텍스트를 암호화 하기 때문에 내용이 노출되는 것을 막아줍니다.
이러한 이유 때문에, HTTP에서 HTTPS로 바꾸는 작업을 했습니다.

SSL/TLS이란 무엇인가요?
SSL보다 TLS가 업그레이드된 버젼입니다. 제공하는 서비스는 무경설, 기밀성, 인증서를 통한 상호인증(서버,클라이언트)입니다.
특정 사이트는 사이트 정보와 사이트 공개키를 기관에게 제출합니다. 
기관은 사이트 정보와 공개키를 암호화한 사이트 인증서를 특정사이트에게, 인증기관 공개키는 웹브라우저(구글, 사파리, 익스플로어 등)에게 제공합니다. 
사용자가 웹브라우저를 통해 특정사이트에 접속하면 특정사이트는 자신의 인증서를 웹브라우저에게 보냅니다. 
인증서를 받은 웹브라우저는 인증기관의 공개키로 서버 인증을 하고 대칭키를 특정사이트에게 보내줍니다. 

  
<HTTPS에서 Nginx를 적용한 이유>

https를 적용하기위해서 자료를 찾다가 nginx을 알게 되었고 이는 사용이 매우 심플하고 규모가 작은 서비스이면서 정적 데이터 처리가 많은 서비스에 적합하다는 것을 알게 되었습니다. 
이 이점을 살려 nginx를 적용하게 되었습니다.
Let's Encrypt(렛츠 인쿠루프트)의 방법은 무료의 TLS/SSL 인증서를 쉽게 가져오고 설치할 수 있는 방법을 제공하는 CA(인증 기관)으로, 웹 서버에서 암호화된 HTTPS를 사용할 수 있습니다.
이러한 방법은 사용자에게 Certbot(서트봇)라는 소프트웨어를 제공함으로써 구현할 수 있게 합니다.

웹서버란 무엇인가요? 
웹서버는 클라이언트의 요청을 받아서 정적 컨텐츠를 제공하는 서버입니다. 예를 들어 단순HTML, CSS, 이미지 등 즉시 응답이 가능한 컨텐츠입니다.(웹서버의 대표적인 Apache, Nginx)
하지만, 동적 컨텐츠를 요청 받으면 WAS에게 해당 요청을 넘겨주고, WAS에서 클라이언트에게 전달해줍니다. 


WAS란 무엇인가요?
WAS는 웹서버가 처리 할 수 없는 것들을 처리해 준다. 특히 DB의 조회나 다양한 로직처리가 필요한 동적 컨텐츠를 처리하여 서비스를 클라이언트에게 제공한다. (WAS의 대표적인 Tomcat, Jeus 등이 존재)
그렇다면, WAS만 사용하면 되지 않을까라는 생각을 할 수 있습니다.
하지만, WAS는 DB조회 및 다양한 로직을 처리하는 데 집중해야 합니다. 만약 WAS로만 설계하게 되면, 효율성이 크게 떨어지기 때문입니다. 
단순한 정적 컨텐츠는 웹서버에게 맡기는 기능을 분리시키고 동적인 것을 WAS에게 맡긴다면, 서버 부하를 방지할 수 있습니다.


클라이언트 → Web서버 →DB

클라이언트 → WAS → DB

클라이언트 → Web서버 → WAS →DB (효율적인 분산 처리로 인해 서버 부하를 방지가능)

HTTPとは何でしょうか
httpは、Web browserとserver間のWebページなどの資源をやり取りするときに使う通信規約です。 
このように規約がありますので、すべてのプログラムがこの規則に沿って開発し、お互い情報を交換することができます。
HTTPは接続状態を維持していない非連結性プロトコルです。これを改善するためにCOOKIEとSESSIONが登場しました。

HTTPSとは何でしょうか
HTTPプロトコルのsecurity versionです。認証書を通して暗号化および認証により、セキュリティがさらに強化されます。

HTTPSを適用した理由は何ですか？
HTTPは単純なテキスト交換ですので、内容が表示されることがあります。しかし、HTTPSはHTTPのSSL(TLS)という認証書を利用してテキストを暗号化するため、内容が表示されることを防ぎます。
こうした理由のため、HTTPからHTTPSに変える作業をしました。

SSL/TLSとは何ですか？
SSLよりTLSがアップグレードされたバージョンです。
提供するサービスは、無経説、機密性、認証書による相互認証(server、Client)です。
特定のサイトはサイト情報とサイト公開キーを機関に提出します。

<HTTPSでNginxを適用した理由>
httpsを適用するために資料を探していたら、nginxを知り、これはとてもシンプルで規模の小さいサービス、静的データ処理が多くのサービスに適しているということを知りました。
この点を活かしてnginxを適用することになりました。
Let's Encryptの方法は無料のTLSSSL認証書を簡単に取得しインストールできる方法を提供するCA（認証機関）で、web serverで暗号化されたHTTPSを使用できます。
このような方法は、ユーザーにCertbotというソフトウェアを提供することによって実現できるようにします。

web serverは何でしょうか
Web serverはClientの要請を受けて静的コンテンツを提供するサーバです。例えば、単純HTML、CSS、画像など、即座に応答できるコンテンツです（Web serverの代表的なApache、Nginx）。
しかし、動的コンテンツの要請を受けたらWASにその要請を渡し、WASからClientに渡します。

WASは何でしょうか
WASはweb serverが処理できないことを処理してくれます。特にDBの照会や様々なロジック処理が必要な動的コンテンツを処理してサービスをClientに提供します。
(WASの代表的なTomcat、Jeusなどが存在)
それなら、WASだけ使えばいいんじゃないかと思います。
しかし、WASはDB照会および様々なlogic処理に集中しなければなりません。WASだけで設計すると効率性が落ちるからです。
単なる静的コンテンツは、Web serverに任せる機能を分離させ、動的なものをWASに任せればServer負荷を防止できます。

Client → Web server → DB

Client → WAS → DB

Client → Web server(静的コンテンツ) → WAS(動的コンテンツ) → DB (効率的な分散処理によりServer負荷を防止可能)
--------------------------------------------------------------------------------------------------------------------

10/18

@NoArgsConstructor : 파라미터가 없는 생성자를 생성한다.

주의 : 

1. 필드들이 final로 생성되어 있는 경우에는 필드를 초기화 할 수 없기 떄문에, 생성자를 만들 수 없다.
@NoArgsConstructor(force = true)옵션을 이용해서 final필드를 0,false,null등으로 초기화를 강제로 시켜 만들 수 있다.

2. @NonNull같이 필드에 제약조건이 설정되어 있는 경우, 생성자내 null-check로직이 생성되지 않는다.

@RequiredArgsConstructor : 추가 작업을 필요로 하는 필드에 대한 생성자를 생성하는 어노테이션이다.
초기화 되지 않은 모든final필드, @NonNull이 적용되어 있는 모든 필드에 자동적으로 생성자를 생성해 준다.
@NonNull로 마크돼있는 필드들은 null-check가 추가적으로 생성되며, @NonNull이 마크되어 있지만, 파라미터에서 null값이 들어온다면 생성자에서 NullPointerException이 발생한다.
파라미터의 순서는 클래스에 있는 필드 순서에 맞춰서 생성해야 된다.

@AllArgsConstructor : 클래스에 존내하는 모든 필드에 대한 생성자를 자동으로 생성해준다.
만약 필드중에서 @NonNull 애노테이션이 마크되어 있다면 생성자 내에서 null-check 로직을 자동적으로 생성한다.

  
생성자 관련 애노테이션을 사용할 때 주의사항

1. static 필드들은 스킵 
2. 파라미터의 순서는 클래스에 있는 필드 순서에 맞춰서 생성하기 때문에 매우 주의. 
→ 만약 클래스 필드의 순서를 바꾸었을 때 롬복이 자동적으로 생성자 파라미터 순서를 바꾸어 주기 때문에 주의하지 않으면 버그가 발생할 수 있다. 
3. AccessLevel을 꼭 설정.
→ 세 애노테이션 모두 접근 제한자를 AccessLevel로 설정할 수 있다.
기본값은 public이지만 필요로 따라서 접근제한자를 설정해줘야 한다.


@NoArgsConstructor : parametersがないconstructorを生産します。

1.フィールドがfinalで生成されている場合には、フィールドを初期化することができないため、constructorを作ることができません。
@NoArgsConstructor(force = true)で、finalフィールドを0,false,nullなどで初期化させるのができます。

2. @NonNullがフィールドに設定されている場合、constructoでnull-checkのlogicができません。

@RequiredArgsConstructor：追加作業を必要とするフィールドに対するconstructorを生成するアノテーションであります。
初期化されていない全てのfinalフィールド、@NonNullが適用されている全てのフィールドに自動的にconstructorを生成してくれます。
@NonNullとマークされているフィールドは、null-checkが追加で生成され、@NonNullがマークされているが、parametersからnull値が入ってくるなら、constructorからNullPointerExceptionが発生する。
@AllArgsConstructor：クラスに存内する全てのフィールドに対するconstructorを自動で生成してくれます。
もし、フィールド中に@NonNull アノテーションがマークされているなら、constructorの中でnull-checkロジックを自動的に生成します。

constructorに関するAnnotationを作るとき気を付けなければならないこと
1.staticフィールドはスキップ。
2.parametersの順序はクラスにあるフィールド順序に合わせて生成するため極めて注意。
3.Access Levelを必ず設定。
--------------------------------------------------------------------------------------------------------------

10/19

생성자(constructor)란 new연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.

생성자 선언방법은 public 클래스(parameters){
           ......
} 

클래스라는 부분은 생성자를 정의하는 클래스의 이름과 동일하게 적어줘야한다.
인스턴스(Instance)란 메모리에 생성된 클래스를 의미한다.
new 연산자를 사용해 메모리 상에 클래스를 생성(인스턴스)하고 이 생서된 주소(인스턴스의 주소)를 return하여 레퍼런스 변수에 저장한다.

ex) 클래스명 레퍼런스변수 = new 클래스명( );

constructorとは、newと一緒に使用され、クラスからオブジェクトを生成するときに呼び出され、オブジェクトの初期化を担当します。
constructor作る方法は、
              public class (parameters){
           ......
} 
classの部分はconstructorを定義するclassの名前の同じように付けなければならないです。
Instanceというのはメモリに生成されたクラスを意味します。
　
ex)　クラス名　リファレンス変数 = new クラス名( );
--------------------------------------------------------------------------------------------------------------

10/20

JPA와 ORM

ORM이란 무엇인가?
ORM이란 객체와 DB의 테이블이 매핑을 이루어지는 것을 말합니다. ORM를 이용하면 SQL Query가 아닌 코드로서 데이터를 조작할 수 가 있습니다.
MySql에서 SELECT*FROM user;라는 query를 실행해야 하지만, ORM를 사용하면, user.findAll()라는 코드로 데이터 조회가 가능합니다. 따라서 생산성이 높아지게 됩니다.

JPA란 무엇인가?
JPA는 ORM의 기술 표준입니다. Hibernate, OpenJPA등이 JPA를 구현한 구현체입니다.
Spring Data JPA는 JPA를 쓰기 편하게 만들어 놓은 모듈로 개발자가 JPA를 더 쉽고 편하게 사용할 수 있도록 도와줍니다.
JPA를 한단계 추상화 시킨 Repository라는 인터페이스를 제공함으로써 이루어집니다.  사용자가 Repository 인터페이스에 정해진 규칙대로 메소드를 입력하면, 
Spring이 알아서 해당 메소드 이름에 적합한 쿼리를 날리는 구현체를 만들어 Bean으로 등록해줍니다.


JPAとORM

ORMとは何でしょうか
ORMはオブジェクトとDBのテーブルがマッピングされることです。ORMを利用すると、SQL Queryではなくコードを使ってデータを操作することができます。
MySqlではSELECT*FROMuser;というqueryを実行しなければなりませんが、ORMを使うとuser.findAll()というコードでデータ照会が可能です。したがって、生産性が高まります。

JPAとは何でしょうか
JPAはORMの技術標準です。Hibernate、OpenJPAなどがJPAの実装体です。
Spring Data JPAは、JPAが使いやすくなっているモジュールで、開発者がJPAをより容易に使いやすいようサポートします。
JPAを抽象化したRepositoryというインタフェースを提供することによって行われます。ユーザがRepositoryインタフェースに定められたルールに従ってmethodを入力すると、
Springがmethodに合うクエリを送ってオブジェクトをBeanで登録します。
--------------------------------------------------------------------------------------------------------------

10/21

PATCH와 PUT의 차이점
PUT는 리소스의 모든 것을 업데이트(수정) 하는 것입니다. PATCH는 리소스의 일부를 업데이트(수정) 하는 것입니다.


CORS란 무엇입니까?
HTTP 헤더를 사용해서 애플리케이션이 다른 Origin의 리소스에 접근할 수 있도록 하는 것입니다. 또한 다른 origin에서 리소스에 접근하지 못하게 하기 위해서도 사용됩니다.

CORS는 왜 필요하고, 어떻게 동작하나요?
사이트의 세션을 악의적으로 탈취하고 다른 행동을 할 수 있는 것을 방지하기 위해서 필요합니다. CORS는 허용한 origin들만 요청할 수 있도록 되어 있습니다. 
브라우저가 리소스를 요청할 때 추가적인 헤더에 정보를 담습니다. 내 origin은 무엇이고 어떤 메소드를 사용해서 요청을 할 것이고 어떤 헤더들을 포함할 것인지를 담아서 서버에 전송합니다. 
서버는 서버가 응답할 수 있는 origin들을 헤더에 담아서 브라우저에게 보냅니다. 
브라우저가 이 헤더를 보고 해당 origin에서 요청할 수 있다면 리소스 전송을 허용하고 만약 불가능하다면 에러를 발생시킵니다.

PATCHとPUTの違い
PUTはリソースの全てをアップデートすることです。PATCHはリソースの一部をアップデート（修正）するものです。

CORSとは何でしょうか
httpheaderを使って、アプリケーションが他のOriginのリソースにアクセスできるようにするものです。また、他のoriginでリソースにアクセスできないようにするためにも使っています。

CORSはなぜ必要で、どのように動作するのですか？
サイトのセッションを悪意を持って奪い、他の行動を起こすことを防止するために必要となります。
web browserがリソースを要求するときに、追加のheaderに情報を入れます。自分のoriginは何か、どのmethodを使って要請するのか、どのheaderを含めるのかを入れてserveerに送信します。
serverはserverが応答できるoriginをheaderに入れてbrowserに送信します。
browserがこのheaderを見て、該当originで要請できる場合は、リソースの送信を許可し、もし不可能ならエラーを発生させます。
--------------------------------------------------------------------------------------------------------------

10/22

AOP가 필요한 상황
모든 메소드의 호출 시간을 측정하고 싶을 때
공통 관심 사항(cross-cutting concern) vs 핵심 관심 상항(core concern)
회원가입 시간, 회원 조회 시간을 측정하고 싶을 때

aop를 사용하지 않고 코드로 메소드 호출시간을 측정하는 방법은
long start = System.currentTimeMillis();
        try {
            validateDuplicateMember(member); //중복 회원 검증重複会員検証       ->
            memberRepository.save(member);                                    ->    핵심 관심 사항(core concern)
            return member.getId();                                            ->
        }finally {
            long finish = System.currentTimeMillis();                          ->
            long timeMs = finish - start;                                      ->    공통 관심 사항(cross-cutting concern)
            System.out.println("join = "+timeMs+"ms");                         ->
        }
와 같은 방법을 사용해야 된다(사용 할 수 있다). 위와 같은 시간측정하는 코드는 유지보수가 어렵고, 시간을 측정하는 별도의 공통 로직을 만들기 어렵다.
위와 같은 코드의 단점을 보완하기 위해 AOP가 나왔다.

AOP방법으로
@Aspect
@Component -> Spring Bean에 등록해도 되고 Component를 사용해도  
public class TimeTraceAop {
    @Around("execution(*hello.spring.demo...*(..))")
    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable{
        long start = System.currentTimeMillis();
        System.out.println("START:" + joinPoint.toString());
        try {
            Object result = joinPoint.proceed();
            return result;
        }finally {
            long finish = System.currentTimeMillis();
            long timeMs = finish - start;
            System.out.println("END:" + joinPoint.toString() + "" + timeMs + "ms");
        }

    }
}으로 공통관심 사항을 분리한 후, 변경이 필요하면 이 로직만 변경하면 되기때문에, 핵심 관심사항을 클린하게 관리할 수 있다.
AOP는 EnhancerBySpringCGLIB라는 기술을 이용해 클래스를 복제한다. 
Spring Container가 Proxy의 가짜서비스 내세우고 joinPoint.proceed()가 되면 실제 서비스를 호출하게 되는 과정으로 AOP가 구현된다.
--------------------------------------------------------------------------------------------------------------
