## 11/1
### 예외처리란(Exception, Error Handling)

```
try {
// 예외가 발생할 가능성이 있는 코드를 구현합니다.
} catch (FileNotFoundException e) {
// FileNotFoundException이 발생했을 경우,이를 처리하기 위한 코드를 구현합니다.
} catch (IOException e) {
// FileNotFoundException이 아닌 IOException이 발생했을 경우,이를 처리하기 위한 코드를 구현합니다.
} finally {
// 예외의 발생여부에 관계없이 항상 수행되어야하는 코드를 구현합니다.
}
```
- 모든 Exception는 Throwable의 자손 클래스입니다. 또한, 프로그램이 종료되지는 않지만, 예외나 문제상황을 표현하기 위해 사용됩니다.
- OutOfMemoryEroor는 할당 받을 수 있는 최대 메모리를 사용해서 JVM이 다운됩니다. 이경우에 발생.

### Try-Catch문이외에 Try-With-Resource문

```
public class Main {
  public static void main(String[] args) {
      try (FileOutputStream out = new FileOutputStream("test.txt")) {
          // test.txt file 에 Hello world 를 출력
          out.write("Hello wrold".getBytes());
          out.flush();
          } catch (IOException e) {
            e.printStackTrace();
      }
  }
}
```
- 입력과 출력을 사용할 때 자주 사용하는 방법.

### Method에서 예외 Exception선언
```
void method() throws IndexOutOfBoundsException, IllegalArgumentException {
//메소드의 내용
}
```
---

## 11/2
-  장례식
-  お葬式

---

## 11/3
- 장례식
- お葬式

---

## 11/4
- 장례식
- お葬式

---

## 11/5

### SSH란
- Secure Shell Protocol, 즉 네트워크 프로토콜 중 하나로 컴퓨터와 컴퓨터가 인터넷과 같은 Public Network를 통해 서로 통신을 할때, 보안적으로 안전학게 통신을 하기위해 사용하는 프로토콜입니다.
- 1. 데이터 전송으로 Git Hub이 존재합니다. 
- 2. 원격제어로 AWS와 같은 클라우드 서비스를 사용할때입니다. AWS의 인스턴스 서버에 접속하여 해당 머신에 명령을 내리기 위해서도 SSH에 접속해야합니다.

### SSH와 FTP, Telnet의 차이
- SSH는 보안적면에서 FTP와 Telnet보다 좋습니다. 그 이유는, 직접 네트워크를 통해 정보를 넘기지 않기 때문입니다. SSH는 Private Key와 Public Key로 컴퓨터 인증을 합니다. Public Key는 암호화시켜서 데이터를 전송하면 컴퓨터 내부에 저장되어 있는 Private Key로 암호화된 메세지를 볼 수 있습니다(Public Key로는 절대 볼수없음). 그렇기 때문에 보안면에서 뛰어난 성능을 보여주고 있습니다. 

---

## 11/6

- 알고리즘
### Jenkins란 무엇인가
- 모든 언어의 조합과 소스 코드 레포지토리에 대한 지속적인 통합(Continuous integration, CI)과 지속적 배포(continuous delivery, CD) 환경을 구축하기 위한 도구입니다. 빌드, 테스트, 배포 프로세스를 자동화하여 소프트웨어 품질과 개발 생산성을 높일 수 있다. 젠킨스는 자바 8의 war 아카이브 또는 설치 패키지, 홈브루(Homebrew) 패키지, 도커 이미지, 그리고 소스코드 형태로 사용할 수 있습니다. 젠킨스 war를 단독으로 톰캣 또는 WAS와 같은 서버렛(Serverlet)으로 실행할 수 있습니다. 위 어플리케이션을 통해 웹 사용자 인터페이스를 생성해 Rest API의 기능을 수행합니다.

- Exception 
```
class ArrayCalculation {

    int[] arr = { 0, 1, 2, 3, 4 };

    public int divide(int denominatorIndex, int numeratorIndex) throws ArithmeticException, ArrayIndexOutOfBoundsException{
        return arr[denominatorIndex] / arr[numeratorIndex];
    }
}-> throws를 통해서, Exception 핸들러를 해줘야된다는걸 알려준다.

public class Main {
    public static void main(String[] args) {
        ArrayCalculation arrayCalculation = new ArrayCalculation();

        System.out.println("2 / 1 = " + arrayCalculation.divide(2, 1));
        try {
            System.out.println("1 / 0 = " + arrayCalculation.divide(1, 0)); // java.lang.ArithmeticException: "/ by zero"
        }catch (ArithmeticException arithmeticException){
            System.out.println("잘못된 계산입니다." + arithmeticException.getMessage());
        }
        try {
            System.out.println("Try to divide using out of index element = "
                    + arrayCalculation.divide(5, 0)); // java.lang.ArrayIndexOutOfBoundsException: 5
        }catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException){
            System.out.println("잘못된 index범위로 나누었습니다. index 범위는" + (arrayCalculation.arr.length - 1)+"입니다.");
        }

    }

}
```
---

## 11/7

## 날짜와 시간을 다루기

```
public class Main {
    public static void main(String[] args) {
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd h/mm");
        String now = dateTimeFormatter.format(LocalDateTime.now());
        System.out.println(now);
    }
}
```
### https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html

```
LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(1992, 4, 4);
Period period = Period.between(today, birthday);
System.out.println(period.getMonths());
System.out.println(period.getDays());
```

##  컬렉션(Collection) = 리스트(List), 스택(Stack) ,큐(Queue), 셋(Set), 맵(Map)

- List : 순서가 있는 데이터의 집합이며 데이터의 중복을 허용합니다.
→ ArrayList, LinkedList, Stack 등

- Set : 순서를 유지하지 않는 데이터의 집합이며 데이터의 중복을 허용하지 않습니다.
→ HashSet, TreeSet 등

- Map : 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합입니다. 순서는 유지되지 않으며 키는 중복을 허용되지 않고 값은
중복을 허용합니다.→ HashMap, TreeMap 등

- Stack : 마지막에 넣은 데이터를 먼저 꺼내는 자료구조입니다. LIFOLast In First Out)
→ Stack, ArrayDeque 등

- Queue : 먼저 넣은 데이터를 먼저 꺼내는 자료구조입니다. FIFOFirst In First Out)
→ Queue, ArrayDeque 등

## List/Set
```
List<Integer>integerList = new ArrayList<>(); // 배열 그래도 전부 순서대로 나온다.
        Set<Integer>integerSet = new HashSet<>(); // 중복값이 나오지 않고 순서대로 나오지 않는다.
        //stringSet.remove(); -> 하나 삭제
        //stringSet.removeAll(); -> 여러개 삭제
        //stringSet.contains(); -> 포함되어 있는지 trus/false로 return
```
## Map
```
 Map<Integer, String>map = new HashMap<>();
        map.put(1, "Laphoo");
        map.put(2, "Dori");
        map.put(3,"Bam");
        System.out.println(map);
        //map.get(1)->Laphoo
        //map.get(2)->Dori
        //map.get(3)->Bam -> key값으로 value값이 나옴
        //map.containKey->key값이 존재하는지 true/false
        //map.containValue->value값이 존재하는지 true/false
```
## Stack/Queue
```
 Stack<Integer> stack = new Stack<>();
        stack.push(4);
        stack.push(4);
        stack.push(2);
        stack.push(23);
        System.out.println(stack);
        System.out.println(stack.peek()); //23return
        System.out.println(stack.size()); //size 4
        System.out.println(stack.pop()); //23return
        System.out.println(stack.size()); //size 3
        System.out.println(stack.contains(1)); //ture

        Queue<Integer>queue = new LinkedList<>();
        queue.add(1);
        queue.add(5);
        queue.add(3);
        System.out.println(queue);
        System.out.println(queue.poll()); //1
        System.out.println(queue.size()); //[5,3]
        System.out.println(queue.peek()); //5
        System.out.println(queue);//[5,3]
```
## ArrayDeque
- ArrayDeque는 Stack, Queue의 기능을 모두 포함하면서도 성능이 더 좋습니다. deque의 경우 양끝에서 삽입과 반환이 가능합니다.
```
ArrayDeque<Integer>arrayDeque = new ArrayDeque<>();
        arrayDeque.addFirst(1);
        arrayDeque.addFirst(2);
        arrayDeque.addFirst(3);
        arrayDeque.addFirst(4);
        System.out.println(arrayDeque); // 4 3 2 1
        arrayDeque.addLast(0);
        System.out.println(arrayDeque); // 4 3 2 1 0
        arrayDeque.offerFirst(10);
        System.out.println(arrayDeque); // 10 4 3 2 1 0 특징 크기의 문제가 생길 때 false값을 return
```
- Stack/Queue의 기능도 전부 사용 가능하다.

##  제네릭스(Generics)란?
- 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능을 의미합니다.
- 제네릭스를 왜 사용해야할까? → 객체의 타입을 컴파일 시에 체크하기 때문에 안정성이 높아집니다.

 ```
 class CustomStack<T> {
    
    List<T> customStack = new ArrayList<>();
    
    public void pop( T inputItem ) {
        customStack.add( inputItem );
    }
    
}
 
public class GenericEx_1 {
    
    public static void main(String[] args) {
        CustomStack<String> stringStack = new CustomStack();
        
        CustomStack<Integer> integerStack = new CustomStack();
    
        stringStack.pop( "홍길동" );
        stringStack.pop( 44529928528223 );
    }
    
}
```
- 홍길동이라는string는 return, int값은 return되지 않고 컴파일 에러 발생합니다. 이와 같이 Generics를 사용하면, 에러를 방지가능하여 코드의 질을 높일 수 있습니다.

##  람다식(Lambda expression)이란?
- 식별자 없이 실행 가능한 함수라고 말할 수 있습니다. 즉, 함수의 이름을 따로 정의하지 않아도 곧바로 함수처럼 사용할 수 있는 것입니다. 문법이 간결하여 보다 편리한 방식입니다. 
- 하지만,  람다를 사용하여서 만든 익명 함수는 재사용이 불가능합니다. 람다만을 사용할 경우 비슷한 메소드를 중복되게 생성할 가능성이 있으므로 지저분해질 수 있는 단점이 있습니다.
```
List<String>list = new ArrayList<>();
      list.add("korea");
      list.add("japan");
      list.add("usa");
      list.add("Israel");
      Stream<String>stream = list.stream();
      stream.map(str->{
          System.out.println(str);
          return str.toUpperCase();
      }).forEach(System.out::println);
```
- return값으로 koreaKOREA, japanJAPAN, usaUSA, IsraelISRAEL

##  스트림(stream)이란?
- stream은 데이터의 흐름입니다. 또한, 컬렉션의 저장 요소를 하나씩 참조해서 람다식으로 처리할 수 있도록 해주는 반복하는 역할도 합니다.
- 스트림을 활용해서 필터링, 데이터 변경, 다른 타입이나 자료구조로 변환 등을 할 수 있습니다.

### Ex1)
```
List<String> list = new ArrayList<>();
        list.add("서울");
        list.add("도쿄");
        list.add("뉴욕");
        list.add("런던");
        list.add("파리");
        list.add("서울");
        System.out.println(list);

       List<String> result = list.stream()
               .limit(2)
               .collect(Collectors.toList());
        System.out.println(result); // 서울, 부산

        Set<String>set = list.stream()
                .filter("서울"::equals)
                .collect(Collectors.toSet());
        System.out.println(set); //중복을 허용하지 않아 서울만 리턴됨

    }
```    
### Ex2)
```
String[] arr = {"라푸", "도리", "밤"};
        Stream<String> stringStream = Arrays.stream(arr);
        stringStream.forEach(System.out::println); // 라푸, 도리, 밤
```
### Ex3)
```
class Sale {
    String fruitName;
    int price;
    float discount;

    public Sale(String fruitName, int price, float discount) {
        this.fruitName = fruitName;
        this.price = price;
        this.discount = discount;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Sale> sales = Arrays.asList(
                new Sale("사과", 1000,0.05f),
                new Sale("귤", 2000,0.05f),
                new Sale("메론", 3000,0.05f),
                new Sale("오렌지", 4000,0.05f)
        );
        sales.stream()
                .map(sale -> Pair.of(sale.fruitName,sale.price*(1-sale.discount)))
                .forEach(pair-> System.out.println(pair.getLeft()+"실구매가는:"+pair.getRight()+"원 입니다."));
        //사과실구매가는:950.0원 입니다.
        //귤실구매가는:1900.0원 입니다.
        //메론실구매가는:2850.0원 입니다.
        //오렌지실구매가는:3800.0원 입니다.
    }
}
```
### Ex4)
```
List<Integer>list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        System.out.println(list.stream().reduce(0, Integer::sum)); // 55
```
### Ex5)
```
 List<String> names = Arrays.asList("김정우", "김호정", "이하늘", "이정희", "박정우", "박지현", "정우석", "이지수");
        System.out.println( names.stream()
                .filter(name -> name.startsWith("이"))
                .count());
```
https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--
https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#startsWith-java.lang.String-

---

## 11/08

## 좋은 객체 지향설계의 5가지 원칙(SOLID)

### SRP: 단일 책임 원칙(single responsibility principle)
- 한 클래스는 하나의 책임만 가져야된다. domain, service, repository, controller 등 모든 것이 하나의 클래스 안에 들어가 있으면 안된다. 

### OCP: 개방-폐쇄 원칙 (Open/closed principle)
- 다형성을 활용해서, 기존코드를 바꾸지않고 확장할 수 있다.
- 하지만, 문제점이 존재한다. 예를들어,
```
MemberRepository m = new MemoryMemberRepository(); //기존 코드
MemberRepository m = new JdbcMemberRepository(); //변경 코드 -> 결국 service에서 코드를 고쳐야된다. 이 문제를 해결해주는것이 spring 컨테이너가 해결해준다.
``` 
### LSP: 리스코프 치환 원칙 (Liskov substitution principle)
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
- 예를들어, 자동차의 악셀을 밞으면 앞으로 가는 것을 뒤로 가게 클래스를 만들수 있다. 문제가 되지 않으니깐, 하지만, 리스코트 치환 원칙으로 인해, 악셀은 앞으로만 가야하는 클래스를 만들어야 한다.

### ISP: 인터페이스 분리 원칙 (Interface segregation principle)
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확해지고, 대체 가능성이 높아진다

### DIP: 의존관계 역전 원칙 (Dependency inversion principle)
- 역할에 의존해야지, 구현에 의존하면 안된다. 
MemberRepository m = new MemoryMemberRepository();를 보면, MeberService는 MeberRepository라는 interface뿐만 아니라, MemoryMemberRepository까지 의존하고 있기 때문에 DIP에 위반된다.
---

## 11/9

## 11/10

## 11/11
