## 11/1
### 예외처리란(Exception, Error Handling)

```
try {
// 예외가 발생할 가능성이 있는 코드를 구현합니다.
} catch (FileNotFoundException e) {
// FileNotFoundException이 발생했을 경우,이를 처리하기 위한 코드를 구현합니다.
} catch (IOException e) {
// FileNotFoundException이 아닌 IOException이 발생했을 경우,이를 처리하기 위한 코드를 구현합니다.
} finally {
// 예외의 발생여부에 관계없이 항상 수행되어야하는 코드를 구현합니다.
}
```
- 모든 Exception는 Throwable의 자손 클래스입니다. 또한, 프로그램이 종료되지는 않지만, 예외나 문제상황을 표현하기 위해 사용됩니다.
- OutOfMemoryEroor는 할당 받을 수 있는 최대 메모리를 사용해서 JVM이 다운됩니다. 이경우에 발생.

### Try-Catch문이외에 Try-With-Resource문

```
public class Main {
  public static void main(String[] args) {
      try (FileOutputStream out = new FileOutputStream("test.txt")) {
          // test.txt file 에 Hello world 를 출력
          out.write("Hello wrold".getBytes());
          out.flush();
          } catch (IOException e) {
            e.printStackTrace();
      }
  }
}
```
- 입력과 출력을 사용할 때 자주 사용하는 방법.

### Method에서 예외 Exception선언
```
void method() throws IndexOutOfBoundsException, IllegalArgumentException {
//메소드의 내용
}
```
---

## 11/2
-  장례식
-  お葬式

---

## 11/3
- 장례식
- お葬式

---

## 11/4
- 장례식
- お葬式

---

## 11/5

### SSH란
- Secure Shell Protocol, 즉 네트워크 프로토콜 중 하나로 컴퓨터와 컴퓨터가 인터넷과 같은 Public Network를 통해 서로 통신을 할때, 보안적으로 안전학게 통신을 하기위해 사용하는 프로토콜입니다.
- 1. 데이터 전송으로 Git Hub이 존재합니다. 
- 2. 원격제어로 AWS와 같은 클라우드 서비스를 사용할때입니다. AWS의 인스턴스 서버에 접속하여 해당 머신에 명령을 내리기 위해서도 SSH에 접속해야합니다.

### SSH와 FTP, Telnet의 차이
- SSH는 보안적면에서 FTP와 Telnet보다 좋습니다. 그 이유는, 직접 네트워크를 통해 정보를 넘기지 않기 때문입니다. SSH는 Private Key와 Public Key로 컴퓨터 인증을 합니다. Public Key는 암호화시켜서 데이터를 전송하면 컴퓨터 내부에 저장되어 있는 Private Key로 암호화된 메세지를 볼 수 있습니다(Public Key로는 절대 볼수없음). 그렇기 때문에 보안면에서 뛰어난 성능을 보여주고 있습니다. 

---

## 11/6

- 알고리즘
### Jenkins란 무엇인가
- 모든 언어의 조합과 소스 코드 레포지토리에 대한 지속적인 통합(Continuous integration, CI)과 지속적 배포(continuous delivery, CD) 환경을 구축하기 위한 도구입니다. 빌드, 테스트, 배포 프로세스를 자동화하여 소프트웨어 품질과 개발 생산성을 높일 수 있다. 젠킨스는 자바 8의 war 아카이브 또는 설치 패키지, 홈브루(Homebrew) 패키지, 도커 이미지, 그리고 소스코드 형태로 사용할 수 있습니다. 젠킨스 war를 단독으로 톰캣 또는 WAS와 같은 서버렛(Serverlet)으로 실행할 수 있습니다. 위 어플리케이션을 통해 웹 사용자 인터페이스를 생성해 Rest API의 기능을 수행합니다.

- Exception 
```
class ArrayCalculation {

    int[] arr = { 0, 1, 2, 3, 4 };

    public int divide(int denominatorIndex, int numeratorIndex) throws ArithmeticException, ArrayIndexOutOfBoundsException{
        return arr[denominatorIndex] / arr[numeratorIndex];
    }
}-> throws를 통해서, Exception 핸들러를 해줘야된다는걸 알려준다.

public class Main {
    public static void main(String[] args) {
        ArrayCalculation arrayCalculation = new ArrayCalculation();

        System.out.println("2 / 1 = " + arrayCalculation.divide(2, 1));
        try {
            System.out.println("1 / 0 = " + arrayCalculation.divide(1, 0)); // java.lang.ArithmeticException: "/ by zero"
        }catch (ArithmeticException arithmeticException){
            System.out.println("잘못된 계산입니다." + arithmeticException.getMessage());
        }
        try {
            System.out.println("Try to divide using out of index element = "
                    + arrayCalculation.divide(5, 0)); // java.lang.ArrayIndexOutOfBoundsException: 5
        }catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException){
            System.out.println("잘못된 index범위로 나누었습니다. index 범위는" + (arrayCalculation.arr.length - 1)+"입니다.");
        }

    }

}
```
---

## 11/7

## 날짜와 시간을 다루기

```
public class Main {
    public static void main(String[] args) {
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd h/mm");
        String now = dateTimeFormatter.format(LocalDateTime.now());
        System.out.println(now);
    }
}
```
### https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html

```
LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(1992, 4, 4);
Period period = Period.between(today, birthday);
System.out.println(period.getMonths());
System.out.println(period.getDays());
```

##  컬렉션(Collection) = 리스트(List), 스택(Stack) ,큐(Queue), 셋(Set), 맵(Map)

- List : 순서가 있는 데이터의 집합이며 데이터의 중복을 허용합니다.
→ ArrayList, LinkedList, Stack 등

- Set : 순서를 유지하지 않는 데이터의 집합이며 데이터의 중복을 허용하지 않습니다.
→ HashSet, TreeSet 등

- Map : 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합입니다. 순서는 유지되지 않으며 키는 중복을 허용되지 않고 값은
중복을 허용합니다.→ HashMap, TreeMap 등

- Stack : 마지막에 넣은 데이터를 먼저 꺼내는 자료구조입니다. LIFOLast In First Out)
→ Stack, ArrayDeque 등

- Queue : 먼저 넣은 데이터를 먼저 꺼내는 자료구조입니다. FIFOFirst In First Out)
→ Queue, ArrayDeque 등

## List/Set
```
List<Integer>integerList = new ArrayList<>(); // 배열 그래도 전부 순서대로 나온다.
        Set<Integer>integerSet = new HashSet<>(); // 중복값이 나오지 않고 순서대로 나오지 않는다.
        //stringSet.remove(); -> 하나 삭제
        //stringSet.removeAll(); -> 여러개 삭제
        //stringSet.contains(); -> 포함되어 있는지 trus/false로 return
```
## Map
```
 Map<Integer, String>map = new HashMap<>();
        map.put(1, "Laphoo");
        map.put(2, "Dori");
        map.put(3,"Bam");
        System.out.println(map);
        //map.get(1)->Laphoo
        //map.get(2)->Dori
        //map.get(3)->Bam -> key값으로 value값이 나옴
        //map.containKey->key값이 존재하는지 true/false
        //map.containValue->value값이 존재하는지 true/false
```
## Stack/Queue
```
 Stack<Integer> stack = new Stack<>();
        stack.push(4);
        stack.push(4);
        stack.push(2);
        stack.push(23);
        System.out.println(stack);
        System.out.println(stack.peek()); //23return
        System.out.println(stack.size()); //size 4
        System.out.println(stack.pop()); //23return
        System.out.println(stack.size()); //size 3
        System.out.println(stack.contains(1)); //ture

        Queue<Integer>queue = new LinkedList<>();
        queue.add(1);
        queue.add(5);
        queue.add(3);
        System.out.println(queue);
        System.out.println(queue.poll()); //1
        System.out.println(queue.size()); //[5,3]
        System.out.println(queue.peek()); //5
        System.out.println(queue);//[5,3]
```
## ArrayDeque
- ArrayDeque는 Stack, Queue의 기능을 모두 포함하면서도 성능이 더 좋습니다. deque의 경우 양끝에서 삽입과 반환이 가능합니다.
```
ArrayDeque<Integer>arrayDeque = new ArrayDeque<>();
        arrayDeque.addFirst(1);
        arrayDeque.addFirst(2);
        arrayDeque.addFirst(3);
        arrayDeque.addFirst(4);
        System.out.println(arrayDeque); // 4 3 2 1
        arrayDeque.addLast(0);
        System.out.println(arrayDeque); // 4 3 2 1 0
        arrayDeque.offerFirst(10);
        System.out.println(arrayDeque); // 10 4 3 2 1 0 특징 크기의 문제가 생길 때 false값을 return
```
- Stack/Queue의 기능도 전부 사용 가능하다.

##  제네릭스(Generics)란?
- 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능을 의미합니다.
- 제네릭스를 왜 사용해야할까? → 객체의 타입을 컴파일 시에 체크하기 때문에 안정성이 높아집니다.

 ```
 class CustomStack<T> {
    
    List<T> customStack = new ArrayList<>();
    
    public void pop( T inputItem ) {
        customStack.add( inputItem );
    }
    
}
 
public class GenericEx_1 {
    
    public static void main(String[] args) {
        CustomStack<String> stringStack = new CustomStack();
        
        CustomStack<Integer> integerStack = new CustomStack();
    
        stringStack.pop( "홍길동" );
        stringStack.pop( 44529928528223 );
    }
    
}
```
- 홍길동이라는string는 return, int값은 return되지 않고 컴파일 에러 발생합니다. 이와 같이 Generics를 사용하면, 에러를 방지가능하여 코드의 질을 높일 수 있습니다.

##  람다식(Lambda expression)이란?
- 식별자 없이 실행 가능한 함수라고 말할 수 있습니다. 즉, 함수의 이름을 따로 정의하지 않아도 곧바로 함수처럼 사용할 수 있는 것입니다. 문법이 간결하여 보다 편리한 방식입니다. 
- 하지만,  람다를 사용하여서 만든 익명 함수는 재사용이 불가능합니다. 람다만을 사용할 경우 비슷한 메소드를 중복되게 생성할 가능성이 있으므로 지저분해질 수 있는 단점이 있습니다.
```
List<String>list = new ArrayList<>();
      list.add("korea");
      list.add("japan");
      list.add("usa");
      list.add("Israel");
      Stream<String>stream = list.stream();
      stream.map(str->{
          System.out.println(str);
          return str.toUpperCase();
      }).forEach(System.out::println);
```
- return값으로 koreaKOREA, japanJAPAN, usaUSA, IsraelISRAEL

##  스트림(stream)이란?
- stream은 데이터의 흐름입니다. 또한, 컬렉션의 저장 요소를 하나씩 참조해서 람다식으로 처리할 수 있도록 해주는 반복하는 역할도 합니다.
- 스트림을 활용해서 필터링, 데이터 변경, 다른 타입이나 자료구조로 변환 등을 할 수 있습니다.

### Ex1)
```
List<String> list = new ArrayList<>();
        list.add("서울");
        list.add("도쿄");
        list.add("뉴욕");
        list.add("런던");
        list.add("파리");
        list.add("서울");
        System.out.println(list);

       List<String> result = list.stream()
               .limit(2)
               .collect(Collectors.toList());
        System.out.println(result); // 서울, 부산

        Set<String>set = list.stream()
                .filter("서울"::equals)
                .collect(Collectors.toSet());
        System.out.println(set); //중복을 허용하지 않아 서울만 리턴됨

    }
```    
### Ex2)
```
String[] arr = {"라푸", "도리", "밤"};
        Stream<String> stringStream = Arrays.stream(arr);
        stringStream.forEach(System.out::println); // 라푸, 도리, 밤
```
### Ex3)
```
class Sale {
    String fruitName;
    int price;
    float discount;

    public Sale(String fruitName, int price, float discount) {
        this.fruitName = fruitName;
        this.price = price;
        this.discount = discount;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Sale> sales = Arrays.asList(
                new Sale("사과", 1000,0.05f),
                new Sale("귤", 2000,0.05f),
                new Sale("메론", 3000,0.05f),
                new Sale("오렌지", 4000,0.05f)
        );
        sales.stream()
                .map(sale -> Pair.of(sale.fruitName,sale.price*(1-sale.discount)))
                .forEach(pair-> System.out.println(pair.getLeft()+"실구매가는:"+pair.getRight()+"원 입니다."));
        //사과실구매가는:950.0원 입니다.
        //귤실구매가는:1900.0원 입니다.
        //메론실구매가는:2850.0원 입니다.
        //오렌지실구매가는:3800.0원 입니다.
    }
}
```
### Ex4)
```
List<Integer>list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        System.out.println(list.stream().reduce(0, Integer::sum)); // 55
```
### Ex5)
```
 List<String> names = Arrays.asList("김정우", "김호정", "이하늘", "이정희", "박정우", "박지현", "정우석", "이지수");
        System.out.println( names.stream()
                .filter(name -> name.startsWith("이"))
                .count());
```
https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--
https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#startsWith-java.lang.String-

---

## 11/08

## 좋은 객체 지향설계의 5가지 원칙(SOLID)

### SRP: 단일 책임 원칙(single responsibility principle)
- 한 클래스는 하나의 책임만 가져야된다. domain, service, repository, controller 등 모든 것이 하나의 클래스 안에 들어가 있으면 안된다. 

### OCP: 개방-폐쇄 원칙 (Open/closed principle)
- 다형성을 활용해서, 기존코드를 바꾸지않고 확장할 수 있다.
- 하지만, 문제점이 존재한다. 예를들어,
```
MemberRepository m = new MemoryMemberRepository(); //기존 코드
MemberRepository m = new JdbcMemberRepository(); //변경 코드 -> 결국 service에서 코드를 고쳐야된다. 이 문제를 해결해주는것이 spring 컨테이너가 해결해준다.
``` 
### LSP: 리스코프 치환 원칙 (Liskov substitution principle)
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
- 예를들어, 자동차의 악셀을 밞으면 앞으로 가는 것을 뒤로 가게 클래스를 만들수 있다. 문제가 되지 않으니깐, 하지만, 리스코트 치환 원칙으로 인해, 악셀은 앞으로만 가야하는 클래스를 만들어야 한다.

### ISP: 인터페이스 분리 원칙 (Interface segregation principle)
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확해지고, 대체 가능성이 높아진다

### DIP: 의존관계 역전 원칙 (Dependency inversion principle)
- 역할에 의존해야지, 구현에 의존하면 안된다. 
MemberRepository m = new MemoryMemberRepository();를 보면, MeberService는 MeberRepository라는 interface뿐만 아니라, MemoryMemberRepository까지 의존하고 있기 때문에 DIP에 위반된다.
---

## 11/9

### spring의 진짜 핵심
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - 객체 지향 언어
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

---

## 11/10

### 역할과 구현을 분리

- 자바 언어의 다형성을 활용
- 역할 = 인터페이스,  구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

---

## 11/11

### 인증(Authentication)
- 간단하게 로그인, 특정 서비스를 사용할 때 사용자임을 아이디와 패스워드를 등을 통해서 인증받은것.
### 인가(Authorization)
- 한번 인증한 사용자가 이 후 여러 서비스를 사용할 때, 서비스안에서 서버가 허용해주는것. 

#### 세션(Authorization)
- 세션은 티켓 한장을 반으로 찢어, 한쪽은 서버 한쪽은 사용자가 가지고 있습니다. 서비스를 이용할 때마다 가지고 있는 반쪽 티켓을 확인하는데, 속도가 느리고 서버가 여러대일 경우 세션유지가 어렵습니다.
#### JWT토큰
- HEADER, PAYLOAD, VERIFY SIGNATURE로 구현되어 있습니다. 
- PAYLOAD는 json형식으로 여러 정보들이 들어가 있습니다. 누가 누구에게 발급했는지, 언제까지 유효했는지, 등등
- HEADER는 코튼의 타입, VERIFY SIGNATURE값을 지정하는 alg가 있다. 그렇기 때문에, 보안유지 가능하다. 하지만, 통제가 불가능합니다. 
- 그렇기 때문에, 토큰의 유효시간을 짦게 주는데, 매번 인가를 받을 때 쓰는 수명 짧은 토큰이 access토큰, 이 access토큰을 재발급 받을 때 쓰는거가 refresh토큰입니다.
  https://jwt.io/
---

## 11/12

#### DSP(Demand Side Platform) Manager
- 광고주가 사용하는 광고 관리도구입니다. 광고 등록과 등록한 광고에 대한 심사, 심사 완료 후 집행된 광고의 효과와 비용에 대한 청구 정보 확인 등 여러가지 기능 제공합니다.

---

## 11/13

### MSA환경
- MicroService Architecture의 줄임말이다. 작고 독립적으로 배포 가능한 각각의 기능을 수행하는 서비스로 구성된 프레임워크입니다. 완전히 독립적으로 배포가 가능하고, 다른 기술 스택(개발 언어, 데이터베이스 등)이 사용 가능한 단일 사업 영역에 초점을 둡니다. 즉 하나의 큰 어플리케이션을 여러개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍쳐입니다.

#### 장점
- 서비스 별 개별 배포 가능 ( 배포 시 전체 서비스의 중단이 없음) 요구사항을 신속하게 반영하여 빠르게 배포할 수 있음.
- 특정 서비스에 대한 확장성이 용이함, 클라우드 사용에 적합한 아키텍쳐.
- 장애가 전체 서비스로 확장될 가능성이 적음, 부분적 장애에 대한 격리가 수월함.

#### 단점
- 성능 - 서비스 간 호출 시 API를 사용하기 때문에, 통신 비용이나, Latency가 그만큼 늘어나게 됩니다.
- 테스트 / 트랜잭션 - 서비스가 분리되어 있기 때문에 테스트와 트랜잭션의 복잡도가 증가하고, 많은 자원을 필요로 합니다.
- 데이터 관리 - 데이터가 여러 서비스에 걸쳐 분산되기 때문에 한번에 조회하기 어렵고, 데이터의 정합성 또한 관리하기 어렵습니다.


### Zipkin
- 분산 트랜잭셕 추적을 위한 오픈소스 소프트웨입니다. 비슷한 제품으로 (Jaeger)가 있습니다.
- https://happycloud-lee.tistory.com/216

---

## 11/14

### 역할과 구현의 분리
```
public interface DiscountPolicy {

    //    할인대상 금액
    int discount(Member member, int price);
}
```
할인의 종류(vip에게 1000원할인)
```
public class FixDiscountPolicy implements DiscountPolicy {
    private int discountFixAmount = 1000; //1000원 할인

    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP) {
            return discountFixAmount;
        } else {
            return 0;
        }
    }
}
```
할인의 종류(vip에게 10% 할인)
```
public class RateDiscountPolicy implements DiscountPolicy{

    private int discountPercent = 10;
    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP){
            return price*discountPercent /100;
        }else {
            return 0;
        }
    }
}
```
바꿔끼기만 하면 되기 때문에, 객체지향의 원칙

---

## 11/15

- 생산자 주입
```
private final MemberRepository memberRepository;
private final DiscountPolicy discountPolicy;
  public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
      this.memberRepository = memberRepository;
      this.discountPolicy = discountPolicy;
 }
 ```
 그리고 Appcnfig를 만들어 외부로부터 구현체를 가지고오고, interface만 의존할 수 있도록 설계
 
 ---
 
 ## 11/16

- test코드 작성시, @BeforeEach라는 어노테이션과
```
public void beforeEach(){
        AppConfig appConfig = new AppConfig();
        memberService = appConfig.memberService();
    }
```
코드를 이용해, 각 테스트 전에 실행된다

---

## 11/17

- 우아콘, 야놀자 시청
- 좋은 기업의 조직문화
- 코드리뷰, 성장

---

## 11/18

### Monolithic Architecture(모놀리식 아키텍쳐) 
모놀리식 아키텍쳐란,  마이크로 서비스 아키텍쳐의 반대 되는 개념입니다. 하나의 서비스 또는 애플리케이션이 하나의 거대한 아키텍쳐를 가질 때, 모놀리식하다고 합니다.
모놀리식 아키텍쳐를 갖는 소프트웨어의 특징은, 내부요소간의 의존성이 강하고, 그자체로 강건하다는 점입니다. 그렇기 때문에, 각 비즈니스 컴포넌트들이 하나의 강한 결합 구조를 지니고 통일성이 있습니다. 이는 비즈니스 로직이 서비스에 최적화된 코드를 만들어내는데 좀 더 집중할수 있는 반면, 복합적인 예외를 만들 수 있습니다.

### 장점
1. 개발 초기에 단순한 아키텍쳐 구조와 개발에 용이.
2.어떤 서비스든지 개발되어 있는 환경이 같아서 복잡하지 않음.
3. 쉡게 고가용성 서버 환경 구축 가능.
4. end-to-end 테스트 용이.

### 단점
1. 프로젝트 규모가 커짐에 따라 애플리케이션 구동시간이 늘어나고 빌드, 배포 시간도 늘어남.
2. 조그만한 수정사항이 있으면, 전체를 다시 빌드하고 배포.
3. 많은 양의 코드가 몰려있어 개발자가 모두를 이해 할 수 없고, 유지보수가 힘듬.
4. 일부분의 오류가 전체에 영향
5. 기능별로 기술, 언어, 프레임워크 선택이 힘들다.

모놀리식은 클라이언트의 요청을 받으면 하나의 스레드에서 모든 요청을 실행하므로 로그를 확인하기 쉽지만, MSA의 경우는 각 서비스의 복잡도가 낮아지고 역할분담이 용이하지만, 여러개의 마이크로 서비스간의 통신이 발생해 로그확인이 어렵습니다. 이런 문제 해결하기 위한 방법으로 OpenTracing이 있고 여기서 JAVA와 Spirng 프레임워크 환경에서 손쉽게 연동할 수 있는zopkin이 있습니다.

--- 

## 11/19

### 프레임워크 vs 라이브러리
- 프레임 워크가 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크가 맞다.(JUnit)
- 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리다.(json)

---

## 11/20

### IoC컨테이너, DI컨테이너
- AppConfig처럼 객체를 생성 관리하면서 의존관계를 연결해 주는 것을 말합니다.
- ApplicationContext를 스프링 컨테이너라 합니다. 스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정(구성) 정보로 사용합니다. 여기서 @Bean이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록합니다. 이렇게 스프링 컨테이너에등록된 객체를 스프링 빈이라 합니다. 스프링 빈은applicationContext.getBean() 메서드를 사용해서 찾을 수 있습니다.
- 스프링 컨테이너를 사용하면 어떤 장점이 있을까?

---

## 11/21

리스트 또는 배열이 있을 때, iter + enter 하면 for이 자동으로 완성
```
 String[] beanDefinitionNames = ac.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
        }
```

---

## 11/22
