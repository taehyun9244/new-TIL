## 11/1
### 예외처리란(Exception, Error Handling)

```
try {
// 예외가 발생할 가능성이 있는 코드를 구현합니다.
} catch (FileNotFoundException e) {
// FileNotFoundException이 발생했을 경우,이를 처리하기 위한 코드를 구현합니다.
} catch (IOException e) {
// FileNotFoundException이 아닌 IOException이 발생했을 경우,이를 처리하기 위한 코드를 구현합니다.
} finally {
// 예외의 발생여부에 관계없이 항상 수행되어야하는 코드를 구현합니다.
}
```
- 모든 Exception는 Throwable의 자손 클래스입니다. 또한, 프로그램이 종료되지는 않지만, 예외나 문제상황을 표현하기 위해 사용됩니다.
- OutOfMemoryEroor는 할당 받을 수 있는 최대 메모리를 사용해서 JVM이 다운됩니다. 이경우에 발생.

### Try-Catch문이외에 Try-With-Resource문

```
public class Main {
  public static void main(String[] args) {
      try (FileOutputStream out = new FileOutputStream("test.txt")) {
          // test.txt file 에 Hello world 를 출력
          out.write("Hello wrold".getBytes());
          out.flush();
          } catch (IOException e) {
            e.printStackTrace();
      }
  }
}
```
- 입력과 출력을 사용할 때 자주 사용하는 방법.

### Method에서 예외 Exception선언
```
void method() throws IndexOutOfBoundsException, IllegalArgumentException {
//메소드의 내용
}
```
---

## 11/2
-  장례식
-  お葬式

---

## 11/3
- 장례식
- お葬式

---

## 11/4
- 장례식
- お葬式

---

## 11/5

### SSH란
- Secure Shell Protocol, 즉 네트워크 프로토콜 중 하나로 컴퓨터와 컴퓨터가 인터넷과 같은 Public Network를 통해 서로 통신을 할때, 보안적으로 안전학게 통신을 하기위해 사용하는 프로토콜입니다.
- 1. 데이터 전송으로 Git Hub이 존재합니다. 
- 2. 원격제어로 AWS와 같은 클라우드 서비스를 사용할때입니다. AWS의 인스턴스 서버에 접속하여 해당 머신에 명령을 내리기 위해서도 SSH에 접속해야합니다.

### SSH와 FTP, Telnet의 차이
- SSH는 보안적면에서 FTP와 Telnet보다 좋습니다. 그 이유는, 직접 네트워크를 통해 정보를 넘기지 않기 때문입니다. SSH는 Private Key와 Public Key로 컴퓨터 인증을 합니다. Public Key는 암호화시켜서 데이터를 전송하면 컴퓨터 내부에 저장되어 있는 Private Key로 암호화된 메세지를 볼 수 있습니다(Public Key로는 절대 볼수없음). 그렇기 때문에 보안면에서 뛰어난 성능을 보여주고 있습니다. 

---

## 11/6

- 알고리즘
### Jenkins란 무엇인가
- 모든 언어의 조합과 소스 코드 레포지토리에 대한 지속적인 통합(Continuous integration, CI)과 지속적 배포(continuous delivery, CD) 환경을 구축하기 위한 도구입니다. 빌드, 테스트, 배포 프로세스를 자동화하여 소프트웨어 품질과 개발 생산성을 높일 수 있다. 젠킨스는 자바 8의 war 아카이브 또는 설치 패키지, 홈브루(Homebrew) 패키지, 도커 이미지, 그리고 소스코드 형태로 사용할 수 있습니다. 젠킨스 war를 단독으로 톰캣 또는 WAS와 같은 서버렛(Serverlet)으로 실행할 수 있습니다. 위 어플리케이션을 통해 웹 사용자 인터페이스를 생성해 Rest API의 기능을 수행합니다.

- Exception 
```
class ArrayCalculation {

    int[] arr = { 0, 1, 2, 3, 4 };

    public int divide(int denominatorIndex, int numeratorIndex) throws ArithmeticException, ArrayIndexOutOfBoundsException{
        return arr[denominatorIndex] / arr[numeratorIndex];
    }
}-> throws를 통해서, Exception 핸들러를 해줘야된다는걸 알려준다.

public class Main {
    public static void main(String[] args) {
        ArrayCalculation arrayCalculation = new ArrayCalculation();

        System.out.println("2 / 1 = " + arrayCalculation.divide(2, 1));
        try {
            System.out.println("1 / 0 = " + arrayCalculation.divide(1, 0)); // java.lang.ArithmeticException: "/ by zero"
        }catch (ArithmeticException arithmeticException){
            System.out.println("잘못된 계산입니다." + arithmeticException.getMessage());
        }
        try {
            System.out.println("Try to divide using out of index element = "
                    + arrayCalculation.divide(5, 0)); // java.lang.ArrayIndexOutOfBoundsException: 5
        }catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException){
            System.out.println("잘못된 index범위로 나누었습니다. index 범위는" + (arrayCalculation.arr.length - 1)+"입니다.");
        }

    }

}
```
---

## 11/7

## 날짜와 시간을 다루기

```
public class Main {
    public static void main(String[] args) {
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd h/mm");
        String now = dateTimeFormatter.format(LocalDateTime.now());
        System.out.println(now);
    }
}
```
### https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html

```
LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(1992, 4, 4);
Period period = Period.between(today, birthday);
System.out.println(period.getMonths());
System.out.println(period.getDays());
```

##  컬렉션(Collection) = 리스트(List), 스택(Stack) ,큐(Queue), 셋(Set), 맵(Map)

- List : 순서가 있는 데이터의 집합이며 데이터의 중복을 허용합니다.
→ ArrayList, LinkedList, Stack 등

- Set : 순서를 유지하지 않는 데이터의 집합이며 데이터의 중복을 허용하지 않습니다.
→ HashSet, TreeSet 등

- Map : 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합입니다. 순서는 유지되지 않으며 키는 중복을 허용되지 않고 값은
중복을 허용합니다.→ HashMap, TreeMap 등

- Stack : 마지막에 넣은 데이터를 먼저 꺼내는 자료구조입니다. LIFOLast In First Out)
→ Stack, ArrayDeque 등

- Queue : 먼저 넣은 데이터를 먼저 꺼내는 자료구조입니다. FIFOFirst In First Out)
→ Queue, ArrayDeque 등

## List/Set
```
List<Integer>integerList = new ArrayList<>(); // 배열 그래도 전부 순서대로 나온다.
        Set<Integer>integerSet = new HashSet<>(); // 중복값이 나오지 않고 순서대로 나오지 않는다.
        //stringSet.remove(); -> 하나 삭제
        //stringSet.removeAll(); -> 여러개 삭제
        //stringSet.contains(); -> 포함되어 있는지 trus/false로 return
```
## Map
```
 Map<Integer, String>map = new HashMap<>();
        map.put(1, "Laphoo");
        map.put(2, "Dori");
        map.put(3,"Bam");
        System.out.println(map);
        //map.get(1)->Laphoo
        //map.get(2)->Dori
        //map.get(3)->Bam -> key값으로 value값이 나옴
        //map.containKey->key값이 존재하는지 true/false
        //map.containValue->value값이 존재하는지 true/false
```
## Stack/Queue
```
 Stack<Integer> stack = new Stack<>();
        stack.push(4);
        stack.push(4);
        stack.push(2);
        stack.push(23);
        System.out.println(stack);
        System.out.println(stack.peek()); //23return
        System.out.println(stack.size()); //size 4
        System.out.println(stack.pop()); //23return
        System.out.println(stack.size()); //size 3
        System.out.println(stack.contains(1)); //ture

        Queue<Integer>queue = new LinkedList<>();
        queue.add(1);
        queue.add(5);
        queue.add(3);
        System.out.println(queue);
        System.out.println(queue.poll()); //1
        System.out.println(queue.size()); //[5,3]
        System.out.println(queue.peek()); //5
        System.out.println(queue);//[5,3]
```
## ArrayDeque
- ArrayDeque는 Stack, Queue의 기능을 모두 포함하면서도 성능이 더 좋습니다. deque의 경우 양끝에서 삽입과 반환이 가능합니다.
```
ArrayDeque<Integer>arrayDeque = new ArrayDeque<>();
        arrayDeque.addFirst(1);
        arrayDeque.addFirst(2);
        arrayDeque.addFirst(3);
        arrayDeque.addFirst(4);
        System.out.println(arrayDeque); // 4 3 2 1
        arrayDeque.addLast(0);
        System.out.println(arrayDeque); // 4 3 2 1 0
        arrayDeque.offerFirst(10);
        System.out.println(arrayDeque); // 10 4 3 2 1 0 특징 크기의 문제가 생길 때 false값을 return
```
- Stack/Queue의 기능도 전부 사용 가능하다.
  
