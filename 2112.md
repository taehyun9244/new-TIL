# 12/1

### Annotation
- Annotation에는 상속관계라는 것이 없습니다. 그렇기 떄문에, 어노테이션이 특정 어노테이션을 들고 있는 것을 인식할 수 있는 것은 JAVA가 지원하는 기능이 아니고, Spring이 지원하는 기능입니다.
- @Contoller : 스프링 MVC 컨트롤러 인식
- @Repositou : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환
- @Configuration : 스프링 설정 정보로 인식, 스프링 빈이 싱글톤 유지를 할 수 있도록 추가
- @Service : 사실 service는 특별한 처리를 하지않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있다라는 것을 인식하는 도움을 준다.

### Filter
- includeFilter : componentScen 대상을 추가로 지정합니다.
- excludeFilter : componentScen 에서 제외할 대상을 지정합니다.
- @Component 면 충분하기 떄문에, includerFilter를 사용할 일이 거의 없습니다만, excludeFilter는 여러가지 이유로 가혹 사용 할 때가 있습니다.

### 중복 등록과 충돌

#### 자동 빈 등록 vs 자동 빈 등록
- componentScan에 의해 자동으로 빈이 등록되는데, 그 이림이 같은 경우 spring은 오류를 발생시킵니다.(ConflictingBeanDefinitionException 발생)

#### 수동 빈 등록 vs 자동 빈 등록
- 이 경우에는 수동 빈 등록이 우선권을 가지며, 수동 빈이 자동 빈을 오버라이딩 합니다.
- 수동 빈 등록시 남는 로그
```
Overriding bean definition for bean 'memoryMemberRepository' with a different 
definition: replacing
```
- 만약에 개발자가 의도적으로 이 결과값을 만들었다면, 자동보다는 수동이 우선권을 가지는 것이 좋습니다. 하지만  그렇지 않다면, 버그가 발생을하고 이 버그는 잡기 어려운 버그입니다. 그래서 springboot는 수동 빈 등록과 자동 빈 등록이 충돌하면 오류가 발생하도록 기본 값으로 설정되어 있습니다.

---

# 12/2
```
//2. 공백(" ")으로 문자열 잘라서 배열에 넣기
String str = "동해물과 백두산이 마르고 닳도록 하나님이 보우하사 우리나라 만세";
String[] array = str.split(" ");
		    
//출력				
for(int i=0;i<array.length;i++) {
System.out.println(array[i]);
}
		  
//결과값 
//array[0] = 동해물과
//array[1] = 백두산이
//array[2] = 마르고
//array[3] = 닳도록
//array[4] = 하나님이
//array[5] = 보우하사
//array[6] = 우리나라
//array[7] = 만세
```
---

# 12/3

### 다양한 의존관계 주입 방법

#### 생성자 주입
- 이름 그대로 생성자를 통해서 의존 관계를 주입 받는 방법입니다. 
- 
- 생성자 주입의 특징 
1. 생정자 호출시점에 딱 1번만 호출되는 것이 보장됩니다.
2. 불편, 필수 의존관계에 사용됩니다.
3. 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입됩니다.

```
@Component
public class OrderServiceImpl implements OrderService {
 private final MemberRepository memberRepository;
 private final DiscountPolicy discountPolicy;
 
 @Autowired
 public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
 this.memberRepository = memberRepository;
 this.discountPolicy = discountPolicy;
 }
}
```

#### 수정자 주입(setter주입)
- setter필드의 값을 변경하는 수정자 method를 통해서 의존관계를 주입하는 방법입니다.

- 수정자 주입의 특징
1. 선택, 변경 가능성이 있는 의존관계에 사용됩니다.
2. JavaBean Property 규약의 수정자 method방식을 사용하는 방법입니다.

```
@Component
public class OrderServiceImpl implements OrderService {
 private MemberRepository memberRepository;
 private DiscountPolicy discountPolicy;
 
 @Autowired
 public void setMemberRepository(MemberRepository memberRepository) {
 this.memberRepository = memberRepository;
 }
 
 @Autowired
 public void setDiscountPolicy(DiscountPolicy discountPolicy) {
 this.discountPolicy = discountPolicy;
 }
}
```
- @Autowired의 기본 동작은 주입할 대상이 없으면 오류가 발생합니다. 주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false)로 지정하면 됩니다.

#### 필드 주입
- 이름 그대로 필드에 주입하는 방식입니다.

- 필드주입의 특징
1. 코드가 간결하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다라는 치명적인 단점이 존재.
2. 스프링 설정을 목적으로 하는 @Confirguration같은 곳에서만 특별한 용도로 사용.

```
@Component
public class OrderServiceImpl implements OrderService {

 @Autowired
 private MemberRepository memberRepository;
 
 @Autowired
 private DiscountPolicy discountPolicy;
}

```

#### 일반 method주입
- 일반 method를 통해서 주입 받을 수 있습니다. 
- 한번에 여러 필드를 주입 받을 수 있지만, 잘 사용하지 않습니다.
```
@Component
public class OrderServiceImpl implements OrderService {
 private MemberRepository memberRepository;
 private DiscountPolicy discountPolicy;
 
 @Autowired
 public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
 this.memberRepository = memberRepository;
 this.discountPolicy = discountPolicy;
 }
}

```
