# 12/1

### Annotation
- Annotation에는 상속관계라는 것이 없습니다. 그렇기 떄문에, 어노테이션이 특정 어노테이션을 들고 있는 것을 인식할 수 있는 것은 JAVA가 지원하는 기능이 아니고, Spring이 지원하는 기능입니다.
- @Contoller : 스프링 MVC 컨트롤러 인식
- @Repositou : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환
- @Configuration : 스프링 설정 정보로 인식, 스프링 빈이 싱글톤 유지를 할 수 있도록 추가
- @Service : 사실 service는 특별한 처리를 하지않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있다라는 것을 인식하는 도움을 준다.

### Filter
- includeFilter : componentScen 대상을 추가로 지정합니다.
- excludeFilter : componentScen 에서 제외할 대상을 지정합니다.
- @Component 면 충분하기 떄문에, includerFilter를 사용할 일이 거의 없습니다만, excludeFilter는 여러가지 이유로 가혹 사용 할 때가 있습니다.

### 중복 등록과 충돌

#### 자동 빈 등록 vs 자동 빈 등록
- componentScan에 의해 자동으로 빈이 등록되는데, 그 이림이 같은 경우 spring은 오류를 발생시킵니다.(ConflictingBeanDefinitionException 발생)

#### 수동 빈 등록 vs 자동 빈 등록
- 이 경우에는 수동 빈 등록이 우선권을 가지며, 수동 빈이 자동 빈을 오버라이딩 합니다.
- 수동 빈 등록시 남는 로그
```
Overriding bean definition for bean 'memoryMemberRepository' with a different 
definition: replacing
```
- 만약에 개발자가 의도적으로 이 결과값을 만들었다면, 자동보다는 수동이 우선권을 가지는 것이 좋습니다. 하지만  그렇지 않다면, 버그가 발생을하고 이 버그는 잡기 어려운 버그입니다. 그래서 springboot는 수동 빈 등록과 자동 빈 등록이 충돌하면 오류가 발생하도록 기본 값으로 설정되어 있습니다.

---

# 12/2
```
//2. 공백(" ")으로 문자열 잘라서 배열에 넣기
String str = "동해물과 백두산이 마르고 닳도록 하나님이 보우하사 우리나라 만세";
String[] array = str.split(" ");
		    
//출력				
for(int i=0;i<array.length;i++) {
System.out.println(array[i]);
}
		  
//결과값 
//array[0] = 동해물과
//array[1] = 백두산이
//array[2] = 마르고
//array[3] = 닳도록
//array[4] = 하나님이
//array[5] = 보우하사
//array[6] = 우리나라
//array[7] = 만세
```
---

# 12/3

### 다양한 의존관계 주입 방법

#### 생성자 주입
- 이름 그대로 생성자를 통해서 의존 관계를 주입 받는 방법입니다. 
- 
- 생성자 주입의 특징 
1. 생정자 호출시점에 딱 1번만 호출되는 것이 보장됩니다.
2. 불편, 필수 의존관계에 사용됩니다.
3. 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입됩니다.

```
@Component
public class OrderServiceImpl implements OrderService {
 private final MemberRepository memberRepository;
 private final DiscountPolicy discountPolicy;
 
 @Autowired
 public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
 this.memberRepository = memberRepository;
 this.discountPolicy = discountPolicy;
 }
}
```

#### 수정자 주입(setter주입)
- setter필드의 값을 변경하는 수정자 method를 통해서 의존관계를 주입하는 방법입니다.

- 수정자 주입의 특징
1. 선택, 변경 가능성이 있는 의존관계에 사용됩니다.
2. JavaBean Property 규약의 수정자 method방식을 사용하는 방법입니다.

```
@Component
public class OrderServiceImpl implements OrderService {
 private MemberRepository memberRepository;
 private DiscountPolicy discountPolicy;
 
 @Autowired
 public void setMemberRepository(MemberRepository memberRepository) {
 this.memberRepository = memberRepository;
 }
 
 @Autowired
 public void setDiscountPolicy(DiscountPolicy discountPolicy) {
 this.discountPolicy = discountPolicy;
 }
}
```
- @Autowired의 기본 동작은 주입할 대상이 없으면 오류가 발생합니다. 주입할 대상이 없어도 동작하게 하려면 @Autowired(required = false)로 지정하면 됩니다.

#### 필드 주입
- 이름 그대로 필드에 주입하는 방식입니다.

- 필드주입의 특징
1. 코드가 간결하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다라는 치명적인 단점이 존재.
2. 스프링 설정을 목적으로 하는 @Confirguration같은 곳에서만 특별한 용도로 사용.

```
@Component
public class OrderServiceImpl implements OrderService {

 @Autowired
 private MemberRepository memberRepository;
 
 @Autowired
 private DiscountPolicy discountPolicy;
}

```

#### 일반 method주입
- 일반 method를 통해서 주입 받을 수 있습니다. 
- 한번에 여러 필드를 주입 받을 수 있지만, 잘 사용하지 않습니다.
```
@Component
public class OrderServiceImpl implements OrderService {
 private MemberRepository memberRepository;
 private DiscountPolicy discountPolicy;
 
 @Autowired
 public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
 this.memberRepository = memberRepository;
 this.discountPolicy = discountPolicy;
 }
}

```

---

# 12/4

### 옵션 처리
- 주입할 스프링 빈이 없어도 동작해야 할 때가 있습니다. 그런데 @Autowired만 사용하면 requried옵션의 기본값이 true로 되어 있기 때문에, 자동 주입 대상이 없으면 오류가 발생합니다.

### 자동 주입대상 옵션처리
1. @Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 자제가 호출되지 않음.
2. org.springframework.lang.@Nullable : 자동 주입할 대상이 없으면 null이 입력됨.
3. Optional<> : 자동 주입할 대상이 없으면 Optional.empty 가 입력됨.

### 예제
```
//호출 안됨
@Autowired(required = false)
public void setNoBean1(Member member) {
 System.out.println("setNoBean1 = " + member);
}

//null 호출
@Autowired
public void setNoBean2(@Nullable Member member) {
 System.out.println("setNoBean2 = " + member);
}

//Optional.empty 호출
@Autowired(required = false)
public void setNoBean3(Optional<Member> member) {
 System.out.println("setNoBean3 = " + member);
}

```
- setNoBean1() 은 @Autowired(required=false) 이므로 호출 자체가 안됩니다.
- 그외, setNoBean2(),setNoBean3()는
```
setNoBean2 = null
setNoBean3 = Optional.empty
```
- 출력됩니다.

### 생성자 주입을 선택하자

#### 이유 

1. 생성자 주입은 불변이라는 특징을 가지고 있습니다. 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경하면 안됩니다. 즉 불변해야 됩니다. 또한, 수정자 주입을 사용하면 setXxx 메서드를 public로 열어둬야 됩니다. 이렇게 된다면, 여러명이 개발하는 것이기 때문에, 다른 누군가의 실수로 변경할 수도 있기에, 변경하면 안되는 메서드를 열어두는 것은(public)것은 좋은 설계가 아닙니다. 생성자 주입은 딱 1번만 호출되므로 이후에 호출되지 않아 불변하게 설계가 가능합니다.
2. 생성자 주입은 프레임 워크 없이 순수한 자바 코드를 단위 테스트 하는 경우에 의존관계 주입의 누락을 방지할 수 있습니다.
3. fianl를 사용할 수 있습니다. fianl 키워드를 통해, 설정되지 않는 오류를 미리 막아줍니다. 
4. 생성자 주입 방식은 프레임 워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이기도 합니다.

---

# 12/5

#### 복습
### 문자열에서 정수형으로 바꾸는 방법 - Integer 클래스 parseInt 메서드 사용
```
class StringToInt {
    public static void main(String[] args) {
        String s1 = "100";
        int i1 = Integer.parseInt(s1);
        System.out.println(i1);
    }
}
```
- 출력 결과 : 100

### 문자열에서 double형으로 바꾸는 방법 - Double 클래스 parseDouble 메서드 사용
```
class StringToDouble {
    public static void main(String[] args) {
        String s1 = "100";
        double d1 = Double.parseDouble(s1);
        System.out.println(d1);
    }
}
```
- 출력 결과 : 100.0

## 알고리즘 재미있다.

---

# 12/6

### 시간 복잡도: 알고리즘의 수행시간을 평가

- 시간 복잡도는 일반적으로 빅오 표기법으로 나타냅니다. 연산 횟수가 다항식으로 표현될 경우, 최고차항을 제외한 모든 항과 최고차항의 계수를 제외시켜 나타냅니다. 예를 들어 입력 크기가 n이라고 했을 때 다음과 같이 표기합니다.

- ex 크기가 n이라고 할때
- T(n) = n2 +2n +1 = O(n2) 최고차항만 나타낸다.
- T(n) = 2n = O(n) 최고차항 계수는 제외한다.

```
int func (int n) {
  int sum = 0;     // 대입연산 1회
  int i = 0;       // 대입연산 1회
   
  for(i=0; i < n; i++) {  // 반복문 n+1회
    sum += i;             // 덧셈 연산 n회
  }
  for(i=0; i < n; i++) {  // 반복문 n+1회
    sum += i;             // 덧셈 연산 n회   
  }
  return sum;       // 리턴 1회
}
```
- T(n) = 4n + 5 = O(n)
- 알고리즘 할 떄 시간복잡도를 생각하자. 

---

# 12/7
- System.in 은 byte 값으로 문자 한 개만 읽으면서 해당 문자에 대응되는 아스키코드 값을 저장할 수 있습니다.
```
public class Main {
	public static void main(String[] args) throws Exception {
 
		int a = System.in.read();
		System.out.print(a);
 
	}
}
```
-의해야 할 점은 예외처리를 해주어야합니다.
IOException (java.io 패키지를 import 해야함) 로 메인 옆에 써주어도 되고, 그냥 Exception 으로 처리해도 됩니다.

---

# 12/8

### System.in 그리고 InputStream

#### Stream
- 데이터의 흐름이라고 생각하면 편합니다. 또한, 단방향이기 때문에, 입력과 출력이 동시에 발생할 수 없기에 입력스트림, 출력스트림으로 나눠서 생각해야 됩니다. 
- JAVA에서 가장 기본이 되는 입력스트림은 InputStream이고 출력스트림은 OutStream입니다. 여기서 System.in이 InputStream 타입의 필드입니다.
- InputStream은 입력받은 데이터는 int형으로 저장합니다. 이는 해당 문자의 시스템 또는 운영체제의 인코딩 형식의 10진수로 변수에 저장됩니다. 또한, 1byte만 읽습니다. 컴퓨터의 모든 데이터는byte단위 데이터로 구성되어 있습니다.즉 데이터를 저장하던, 전달하던 컴퓨터에는 바이트 단위로 데이터가 저장되고 있습니다.

---

# 12/9
